from typing import List
import pandas as pd
import json
import time
import jax.numpy as jnp
from .components import RectangularConductor, RectangularSegment
from .field import BiasFields, biot_savart_rectangular
from .potential import Atom, AnalysisOptions, analyze_field, FieldAnalysis, analyze_trap, TrapAnalysis


class AtomChip:
    def __init__(
        self,
        name: str,
        atom: Atom,
        components: List[RectangularConductor],
        bias_fields: BiasFields,
    ):
        """
        Initialize the AtomChip with a name, atom, and components.

        Args:
            name (str): Name of the atom chip.
            atom (Atom): Atom object representing the type of atom used in the chip.
            components (List[RectangularConductor]): List of rectangular conductor segments.
            bias_fields (BiasFields): Bias fields object representing the bias field generated by the atom chip.
        """
        self.name = name
        self.atom = atom
        self.components = components
        self.bias_fields = bias_fields

        # Placeholders for analysis results
        self.field: FieldAnalysis = None
        self.trap: TrapAnalysis = None

    def get_fields(self, points: jnp.array) -> jnp.ndarray:
        """
        Compute the magnetic field at given points in space.

        Args:
            points (jnp.ndarray): Array of points in space where the magnetic field is computed.

        Returns:
            jnp.ndarray: Magnetic field at the given points.
        """
        points = jnp.atleast_2d(points).astype(jnp.float64)

        # Get the bias fields
        B = self.bias_fields.get_fields(points)

        # consolidate all the components into a single call to biot_savart_rectangular
        # to avoid multiple calls to JAX
        # fmt: off
        starts   = jnp.concatenate([component.starts   for component in self.components])
        ends     = jnp.concatenate([component.ends     for component in self.components])
        widths   = jnp.concatenate([component.widths   for component in self.components])
        heights  = jnp.concatenate([component.heights  for component in self.components])
        currents = jnp.concatenate([component.currents for component in self.components])
        # fmt: on

        B = B + biot_savart_rectangular(points, starts, ends, widths, heights, currents)
        B_mag = jnp.linalg.norm(B, axis=1)
        return B_mag, B

    def get_potentials(self, points: jnp.array) -> jnp.ndarray:
        """
        Compute the potential energy at given points in space.

        Args:
            points (jnp.ndarray): Array of points in space where the potential energy is computed.

        Returns:
            jnp.ndarray: Potential energy at the given points.
        """
        points = jnp.atleast_2d(points).astype(jnp.float64)
        B_mag, B = self.get_fields(points)
        z = points[:, 2]
        return self.atom.potential_energy(B_mag, z), B_mag, B

    def analyze(self, options: AnalysisOptions) -> TrapAnalysis:
        """
        Analyze the trap using the given options. The analysises are saved in the object.

        Args:
            options (TrapAnalysisOptions): Options for the trap analysis.

        Returns:
            TrapAnalysis: Result of the trap potential analysis.
        """
        start_time = time.time()
        self.field = analyze_field(self.atom, self.get_fields, options)
        self.trap = analyze_trap(self.atom, self.get_potentials, options)
        end_time = time.time()
        print(f"Analysis completed in {end_time - start_time:.2f} seconds")
        return self.trap

    def to_json(self, path: str = None) -> str:
        """
        Serialize the AtomChip to JSON format.
         - If a path is provided, the JSON is saved to that file.
         - Otherwise, the JSON string is returned.
        """
        data = []
        for component_id, component in enumerate(self.components):
            segment_id = 0
            for start, end, width, height in zip(
                component.starts.tolist(),
                component.ends.tolist(),
                component.widths.tolist(),
                component.heights.tolist(),
            ):
                data.append(
                    {
                        "component_id": component_id,
                        "segment_id": segment_id,
                        "material": component.material,
                        "current": float(component.current),
                        "start": start,
                        "end": end,
                        "width": width,
                        "height": height,
                    }
                )
                segment_id += 1
        if path:
            with open(path, "w") as f:
                json.dump(data, f, indent=2)
        return json.dumps(data, indent=2)

    def from_json(self, path: str):
        """
        Load the AtomChip from a JSON file.

        This simply loads the components from the JSON file.
        The atom and bias fields are not loaded (they remain unchanged).
        Any analysis results are cleared.
        """
        with open(path, "r") as f:
            data = json.load(f)

        # load and sort the data by component_id and segment_id
        data_df = pd.DataFrame(data)
        data_df = data_df.sort_values(by=["component_id", "segment_id"]).reset_index(drop=True)

        # iterate over the components and create a list of RectangularConductor objects
        self.components = []
        for component_id, group in data_df.groupby("component_id"):
            segments = []
            for _, row in group.iterrows():
                segments.append(
                    RectangularSegment(
                        start=row.start,
                        end=row.end,
                        width=row.width,
                        height=row.height,
                    )
                )
            # create a new component and add it to the list
            # fmt: off
            self.components.append(RectangularConductor(
                material = group.iloc[0]["material"],
                current  = group.iloc[0]["current"].astype(float),
                segments = segments,
            ))
            # fmt: on

        # Clear the analysis results
        self.field = None
        self.trap = None
