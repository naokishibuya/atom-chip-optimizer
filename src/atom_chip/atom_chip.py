from typing import List
import jax.numpy as jnp
from .components import RectangularConductor
from .field import BiasFields, biot_savart_rectangular
from .potential import Atom, search_minimum, MinimumResult


class AtomChip:
    def __init__(
        self,
        name: str,
        atom: Atom,
        components: List[RectangularConductor],
        bias_fields: BiasFields,
    ):
        """
        Initialize the AtomChip with a name, atom, and components.

        Args:
            name (str): Name of the atom chip.
            atom (Atom): Atom object representing the type of atom used in the chip.
            components (List[RectangularConductor]): List of rectangular conductor segments.
            bias_fields (BiasFields): Bias fields object representing the bias field generated by the atom chip.
        """
        self.name = name
        self.atom = atom
        self.components = components
        self.bias_fields = bias_fields

        # Initialize the minimum results
        self.B_min: MinimumResult = None
        self.E_min: MinimumResult = None

    def get_fields(self, points: jnp.array) -> jnp.ndarray:
        """
        Compute the magnetic field at given points in space.

        Args:
            points (jnp.ndarray): Array of points in space where the magnetic field is computed.

        Returns:
            jnp.ndarray: Magnetic field at the given points.
        """
        points = jnp.atleast_2d(points).astype(jnp.float64)

        # Get the bias fields
        B = self.bias_fields.get_fields(points)

        # consolidate all the components into a single call to biot_savart_rectangular
        # to avoid multiple calls to JAX
        # fmt: off
        starts   = jnp.concatenate([component.starts   for component in self.components])
        ends     = jnp.concatenate([component.ends     for component in self.components])
        widths   = jnp.concatenate([component.widths   for component in self.components])
        heights  = jnp.concatenate([component.heights  for component in self.components])
        currents = jnp.concatenate([component.currents for component in self.components])
        # fmt: on

        B = B + biot_savart_rectangular(points, starts, ends, widths, heights, currents)
        B_mag = jnp.linalg.norm(B, axis=1)
        return B_mag, B

    def get_potentials(self, points: jnp.array) -> jnp.ndarray:
        """
        Compute the potential energy at given points in space.

        Args:
            points (jnp.ndarray): Array of points in space where the potential energy is computed.

        Returns:
            jnp.ndarray: Potential energy at the given points.
        """
        points = jnp.atleast_2d(points).astype(jnp.float64)
        B_mag, B = self.get_fields(points)
        z = points[:, 2]
        return self.atom.potential_energy(B_mag, z), B_mag, B

    def search_field_minimum(self, options: dict) -> MinimumResult:
        """
        Search for the minimum magnetic field in the given options.

        Args:
            options (dict): Options for the optimization algorithm.

        Returns:
            MinimumResult: Result of the minimum search.
        """

        def objective_function(point: jnp.array) -> float:
            B_mag, _ = self.get_fields(point)
            return B_mag[0]

        print("-" * 100)
        print("Searching for field minimum...[G]")
        self.B_min = search_minimum(objective_function, **options)
        return self.B_min

    def search_potential_minimum(self, options: dict) -> MinimumResult:
        """
        Search for the minimum potential energy in the given options.

        Args:
            options (dict): Options for the optimization algorithm.

        Returns:
            MinimumResult: Result of the minimum search.
        """

        def objective_function(point: jnp.array) -> float:
            E, _, _ = self.get_potentials(point)
            return E[0]

        print("-" * 100)
        print("Searching for potential minimum...[J]")
        self.E_min = search_minimum(objective_function, **options)
        return self.E_min
