from typing import List
import json
import jax.numpy as jnp
from .components import RectangularConductor
from .field import BiasFields, biot_savart_rectangular
from .potential import Atom, AnalysisOptions, analyze_field, FieldAnalysis, analyze_trap, TrapAnalysis


class AtomChip:
    def __init__(
        self,
        name: str,
        atom: Atom,
        components: List[RectangularConductor],
        bias_fields: BiasFields,
    ):
        """
        Initialize the AtomChip with a name, atom, and components.

        Args:
            name (str): Name of the atom chip.
            atom (Atom): Atom object representing the type of atom used in the chip.
            components (List[RectangularConductor]): List of rectangular conductor segments.
            bias_fields (BiasFields): Bias fields object representing the bias field generated by the atom chip.
        """
        self.name = name
        self.atom = atom
        self.components = components
        self.bias_fields = bias_fields

        # Placeholders for analysis results
        self.field: FieldAnalysis = None
        self.trap: TrapAnalysis = None

    def get_fields(self, points: jnp.array) -> jnp.ndarray:
        """
        Compute the magnetic field at given points in space.

        Args:
            points (jnp.ndarray): Array of points in space where the magnetic field is computed.

        Returns:
            jnp.ndarray: Magnetic field at the given points.
        """
        points = jnp.atleast_2d(points).astype(jnp.float64)

        # Get the bias fields
        B = self.bias_fields.get_fields(points)

        # consolidate all the components into a single call to biot_savart_rectangular
        # to avoid multiple calls to JAX
        # fmt: off
        starts   = jnp.concatenate([component.starts   for component in self.components])
        ends     = jnp.concatenate([component.ends     for component in self.components])
        widths   = jnp.concatenate([component.widths   for component in self.components])
        heights  = jnp.concatenate([component.heights  for component in self.components])
        currents = jnp.concatenate([component.currents for component in self.components])
        # fmt: on

        B = B + biot_savart_rectangular(points, starts, ends, widths, heights, currents)
        B_mag = jnp.linalg.norm(B, axis=1)
        return B_mag, B

    def get_potentials(self, points: jnp.array) -> jnp.ndarray:
        """
        Compute the potential energy at given points in space.

        Args:
            points (jnp.ndarray): Array of points in space where the potential energy is computed.

        Returns:
            jnp.ndarray: Potential energy at the given points.
        """
        points = jnp.atleast_2d(points).astype(jnp.float64)
        B_mag, B = self.get_fields(points)
        z = points[:, 2]
        return self.atom.potential_energy(B_mag, z), B_mag, B

    def analyze(self, options: AnalysisOptions) -> TrapAnalysis:
        """
        Analyze the trap using the given options. The analysises are saved in the object.

        Args:
            options (TrapAnalysisOptions): Options for the trap analysis.

        Returns:
            TrapAnalysis: Result of the trap potential analysis.
        """
        self.field = analyze_field(self.atom, self.get_fields, options)
        self.trap = analyze_trap(self.atom, self.get_potentials, options)
        return self.trap

    def to_json(self, path: str = None) -> str:
        data = []
        for component in self.components:
            for start, end, width, height in zip(
                component.starts.tolist(),
                component.ends.tolist(),
                component.widths.tolist(),
                component.heights.tolist(),
            ):
                data.append(
                    {
                        "material": component.material,
                        "current": component.current,
                        "start": start,
                        "end": end,
                        "width": width,
                        "height": height,
                    }
                )
        if path:
            with open(path, "w") as f:
                json.dump(data, f, indent=2)
        return json.dumps(data, indent=2)
