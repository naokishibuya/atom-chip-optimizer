from typing import List
import jax.numpy as jnp
from .components import RectangularConductor
from .field import BiasFields, biot_savart_rectangular
from .potential import Atom, AnalysisOptions, analyze_field, FieldAnalysis, analyze_trap, TrapAnalysis


class AtomChip:
    def __init__(
        self,
        name: str,
        atom: Atom,
        components: List[RectangularConductor],
        bias_fields: BiasFields,
    ):
        """
        Initialize the AtomChip with a name, atom, and components.

        Args:
            name (str): Name of the atom chip.
            atom (Atom): Atom object representing the type of atom used in the chip.
            components (List[RectangularConductor]): List of rectangular conductor segments.
            bias_fields (BiasFields): Bias fields object representing the bias field generated by the atom chip.
        """
        self.name = name
        self.atom = atom
        self.components = components
        self.bias_fields = bias_fields

        # Placeholders for analysis results
        self.field: FieldAnalysis = None
        self.trap: TrapAnalysis = None

    def get_fields(self, points: jnp.array) -> jnp.ndarray:
        """
        Compute the magnetic field at given points in space.

        Args:
            points (jnp.ndarray): Array of points in space where the magnetic field is computed.

        Returns:
            jnp.ndarray: Magnetic field at the given points.
        """
        points = jnp.atleast_2d(points).astype(jnp.float64)

        # Get the bias fields
        B = self.bias_fields.get_fields(points)

        # consolidate all the components into a single call to biot_savart_rectangular
        # to avoid multiple calls to JAX
        # fmt: off
        starts   = jnp.concatenate([component.starts   for component in self.components])
        ends     = jnp.concatenate([component.ends     for component in self.components])
        widths   = jnp.concatenate([component.widths   for component in self.components])
        heights  = jnp.concatenate([component.heights  for component in self.components])
        currents = jnp.concatenate([component.currents for component in self.components])
        # fmt: on

        B = B + biot_savart_rectangular(points, starts, ends, widths, heights, currents)
        B_mag = jnp.linalg.norm(B, axis=1)
        return B_mag, B

    def get_potentials(self, points: jnp.array) -> jnp.ndarray:
        """
        Compute the potential energy at given points in space.

        Args:
            points (jnp.ndarray): Array of points in space where the potential energy is computed.

        Returns:
            jnp.ndarray: Potential energy at the given points.
        """
        points = jnp.atleast_2d(points).astype(jnp.float64)
        B_mag, B = self.get_fields(points)
        z = points[:, 2]
        return self.atom.potential_energy(B_mag, z), B_mag, B

    def analyze(self, options: AnalysisOptions) -> TrapAnalysis:
        """
        Analyze the trap using the given options.
        Args:
            options (TrapAnalysisOptions): Options for the trap analysis.
        Returns:
            TrapAnalysis: Result of the trap analysis.
        """

        # Define the objective function for the field analysis
        def field_function(point: jnp.array) -> float:
            B_mag, _ = self.get_fields(point)
            return B_mag[0]

        self.field = analyze_field(self.atom, field_function, options)

        # Define the objective function for the trap analysis
        def potential_function(point: jnp.array) -> float:
            E, _, _ = self.get_potentials(point)
            return E[0]

        self.trap = analyze_trap(self.atom, potential_function, options)
        return self.trap
